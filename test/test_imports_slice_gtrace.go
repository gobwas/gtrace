// Code generated by gtrace. DO NOT EDIT.

package test

import (
	"bytes"

	"github.com/gobwas/gtrace/test/internal"
)

// Compose returns a new TraceArray which has functional fields composed
// both from t and x.
func (t TraceArray) Compose(x TraceArray) (ret TraceArray) {
	switch {
	case t.OnSomethingA == nil:
		ret.OnSomethingA = x.OnSomethingA
	case x.OnSomethingA == nil:
		ret.OnSomethingA = t.OnSomethingA
	default:
		h1 := t.OnSomethingA
		h2 := x.OnSomethingA
		ret.OnSomethingA = func(t Type) {
			h1(t)
			h2(t)
		}
	}
	switch {
	case t.OnSomethingB == nil:
		ret.OnSomethingB = x.OnSomethingB
	case x.OnSomethingB == nil:
		ret.OnSomethingB = t.OnSomethingB
	default:
		h1 := t.OnSomethingB
		h2 := x.OnSomethingB
		ret.OnSomethingB = func(t []internal.Type) {
			h1(t)
			h2(t)
		}
	}
	return ret
}
func (t TraceArray) onSomethingA(t1 Type) {
	fn := t.OnSomethingA
	if fn == nil {
		return
	}
	fn(t1)
}
func (t TraceArray) onSomethingB(t1 []internal.Type) {
	fn := t.OnSomethingB
	if fn == nil {
		return
	}
	fn(t1)
}
func traceArrayOnSomethingA(t TraceArray, e Embeded, s string, integer int, boolean bool, e1 error, r bytes.Reader) {
	var p Type
	p.Embeded = e
	p.String = s
	p.Integer = integer
	p.Boolean = boolean
	p.Error = e1
	p.Reader = r
	t.onSomethingA(p)
}
func traceArrayOnSomethingB(t TraceArray, t1 []internal.Type) {
	t.onSomethingB(t1)
}

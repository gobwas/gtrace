// Code generated by gtrace. DO NOT EDIT.

package test

import (
	"bytes"

	"github.com/gobwas/gtrace/test/internal"
)

// Compose returns a new TracePointer which has functional fields composed
// both from t and x.
func (t TracePointer) Compose(x TracePointer) (ret TracePointer) {
	switch {
	case t.OnSomethingA == nil:
		ret.OnSomethingA = x.OnSomethingA
	case x.OnSomethingA == nil:
		ret.OnSomethingA = t.OnSomethingA
	default:
		h1 := t.OnSomethingA
		h2 := x.OnSomethingA
		ret.OnSomethingA = func(t Type) {
			h1(t)
			h2(t)
		}
	}
	switch {
	case t.OnSomethingB == nil:
		ret.OnSomethingB = x.OnSomethingB
	case x.OnSomethingB == nil:
		ret.OnSomethingB = t.OnSomethingB
	default:
		h1 := t.OnSomethingB
		h2 := x.OnSomethingB
		ret.OnSomethingB = func(t *internal.Type) {
			h1(t)
			h2(t)
		}
	}
	return ret
}
func (t TracePointer) onSomethingA(t1 Type) {
	fn := t.OnSomethingA
	if fn == nil {
		return
	}
	fn(t1)
}
func (t TracePointer) onSomethingB(t1 *internal.Type) {
	fn := t.OnSomethingB
	if fn == nil {
		return
	}
	fn(t1)
}
func tracePointerOnSomethingA(t TracePointer, e Embeded, s string, integer int, boolean bool, e1 error, r bytes.Reader) {
	var p Type
	p.Embeded = e
	p.String = s
	p.Integer = integer
	p.Boolean = boolean
	p.Error = e1
	p.Reader = r
	t.onSomethingA(p)
}
func tracePointerOnSomethingB(t TracePointer, t1 *internal.Type) {
	t.onSomethingB(t1)
}
